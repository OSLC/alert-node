{"version":3,"sources":["../src/parse.js"],"names":[],"mappings":";;;;;;;;;AAGA,IAAM,OAAO,oIAAP;;AAEN,IAAM,YAAY,SAAZ,SAAY,CAAC,IAAD,EAAO,IAAP,EAAgB;;AAEhC,MAAM,MAAM,KAAK,MAAL,CAAY,CAAZ,MAAmB,GAAnB,GAAyB,mBAAQ,IAAR,CAAzB,GAAyC,KAAK,IAAL,EAAzC;;;AAFoB,MAK5B,MAAM,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACvB,WAAO,KAAK,MAAL,CAAY,GAAZ,CAAP,CADuB;GAAzB,MAEO,IAAI,IAAJ,EAAU;AACf,WAAO,CAAC,IAAD,EAAO,GAAP,CAAP,CADe;GAAV;AAGP,SAAO,GAAP,CAVgC;CAAhB;;AAalB,IAAM,kBAAkB,SAAlB,eAAkB,CAAC,MAAD,EAAS,MAAT,EAAoB;AAC1C,MAAI,MAAM,IAAN,CADsC;AAE1C,MAAI,QAAQ,IAAR,CAFsC;AAG1C,MAAM,SAAS,EAAT,CAHoC;;AAK1C,SAAO,CAAC,MAAM,KAAK,IAAL,CAAU,MAAV,CAAN,CAAD,KAA8B,IAA9B,EAAoC;AACzC,QAAI,IAAI,CAAJ,CAAJ,EAAY;AACV,aAAO,IAAI,CAAJ,CAAP,IAAiB,UAAU,OAAO,IAAI,CAAJ,CAAP,CAAV,EAA0B,IAAI,CAAJ,CAA1B,CAAjB,CADU;KAAZ,MAEO;AACL,cAAQ,UAAU,KAAV,EAAiB,IAAI,CAAJ,CAAjB,CAAR,CADK;KAFP;GADF;;AAQA,SAAO,EAAC,cAAD,EAAS,cAAT,EAAiB,YAAjB,EAAP,CAb0C;CAApB;;kBAgBT,UAAC,GAAD,EAAS;AACtB,MAAI,OAAO,GAAP,KAAe,QAAf,EAAyB;AAC3B,UAAM,IAAI,SAAJ,CAAc,gCAAd,CAAN,CAD2B;GAA7B;;AAIA,MAAM,QAAQ,IAAI,OAAJ,CAAY,GAAZ,CAAR,CALgB;AAMtB,MAAM,SAAS,IAAI,MAAJ,CAAW,CAAX,EAAc,KAAd,CAAT,CANgB;;AAQtB,MAAI,CAAC,oBAAS,MAAT,CAAD,EAAmB;AACrB,UAAM,IAAI,SAAJ,qBAAgC,MAAhC,CAAN,CADqB;GAAvB;;AAIA,SAAO,gBAAgB,MAAhB,EAAwB,IAAI,MAAJ,CAAW,KAAX,CAAxB,CAAP,CAZsB;CAAT","file":"parse.js","sourcesContent":["import {isScheme, unquote} from './util';\n\n// lol dis\nconst body = /((?:[a-zA-Z0-9._~+\\/-]+=*(?:\\s+|$))|[^\\u0000-\\u001F\\u007F()<>@,;:\\\\\"/?={}\\[\\]\\u0020\\u0009]+)(?:=([^\\\\\"=\\s,]+|\"(?:[^\"\\\\]|\\\\.)*\"))?/g; // eslint-disable-line\n\nconst normalize = (prev, _cur) => {\n  // Fixup quoted strings and tokens with spaces around them\n  const cur = _cur.charAt(0) === '\"' ? unquote(_cur) : _cur.trim();\n\n  // Marshal\n  if (Array.isArray(prev)) {\n    return prev.concat(cur);\n  } else if (prev) {\n    return [prev, cur];\n  }\n  return cur;\n};\n\nconst parseProperties = (scheme, string) => {\n  let res = null;\n  let token = null;\n  const params = { };\n\n  while ((res = body.exec(string)) !== null) {\n    if (res[2]) {\n      params[res[1]] = normalize(params[res[1]], res[2]);\n    } else {\n      token = normalize(token, res[1]);\n    }\n  }\n\n  return {scheme, params, token};\n};\n\nexport default (str) => {\n  if (typeof str !== 'string') {\n    throw new TypeError('Header value must be a string.');\n  }\n\n  const start = str.indexOf(' ');\n  const scheme = str.substr(0, start);\n\n  if (!isScheme(scheme)) {\n    throw new TypeError(`Invalid scheme ${scheme}`);\n  }\n\n  return parseProperties(scheme, str.substr(start));\n};\n"]}